<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>- Play Tetris! -</title>
    <link rel="icon" href="https://cdn-icons-png.flaticon.com/512/566/566312.png" type="image/png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* --- Basic Setup & Retro Theming --- */
        :root {
            --bg-color: #0d0d0d;
            --grid-bg: #1a1a1a;
            --grid-line: #333;
            --text-color: #f0f0f0;
            --accent-color: #ff00ff; /* Magenta */
            --button-bg: #00ffff; /* Cyan */
            --button-text: #0d0d0d;
            --modal-bg: rgba(0, 0, 0, 0.85);
            --font-family: 'Press Start 2P', cursive;
        }

        html {
            box-sizing: border-box;
        }
        *, *:before, *:after {
            box-sizing: inherit;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-family);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 1rem;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        /* --- Main Game Layout --- */
        .game-container {
            display: flex;
            gap: 2rem;
            justify-content: center;
            align-items: flex-start;
            flex-wrap: wrap;
        }

        /* --- Game Canvas --- */
        #game-board {
            border: 4px solid var(--accent-color);
            background-color: var(--grid-bg);
            box-shadow: 0 0 20px var(--accent-color);
            image-rendering: pixelated; /* Sharp pixels for retro look */
        }

        /* --- Sidebar for Stats & Controls --- */
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            width: 200px;
            text-align: center;
        }

        .stat-box {
            background-color: var(--grid-bg);
            padding: 1rem;
            border: 2px solid var(--grid-line);
        }

        .stat-box h2 {
            margin: 0 0 0.5rem 0;
            font-size: 1rem;
            color: var(--accent-color);
        }

        .stat-box p {
            margin: 0;
            font-size: 1.5rem;
            color: var(--text-color);
        }

        #next-piece-canvas {
            background-color: var(--grid-bg);
            border: 2px solid var(--grid-line);
            width: 100%;
            height: auto;
            image-rendering: pixelated;
        }
        
        /* --- Buttons & Modals --- */
        .button {
            background-color: var(--button-bg);
            color: var(--button-text);
            border: none;
            padding: 1rem;
            font-family: inherit;
            font-size: 1rem;
            cursor: pointer;
            text-transform: uppercase;
            transition: transform 0.1s ease, box-shadow 0.1s ease;
            box-shadow: 4px 4px 0px #00a1a1;
        }

        .button:hover {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0px #00a1a1;
        }
        
        .button:active {
            transform: translate(4px, 4px);
            box-shadow: 0px 0px 0px #00a1a1;
        }

        /* Hide the initial start button */
        #start-button {
            display: none;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: var(--modal-bg);
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 1rem;
        }

        .modal-content {
            padding: 2rem 3rem;
            background-color: var(--grid-bg);
            border: 4px solid var(--accent-color);
            box-shadow: 0 0 20px var(--accent-color);
        }
        
        .modal-content h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            color: var(--accent-color);
            animation: flicker 1.5s infinite alternate;
        }

        .modal-content p {
            font-size: 0.8rem;
            line-height: 1.5;
            margin-bottom: 1rem;
            text-align: left;
        }
        
        .modal-content .start-prompt {
            font-size: 1rem;
            text-align: center;
            margin-top: 2rem;
            color: var(--button-bg);
            animation: flicker 1.5s infinite alternate;
        }

        @keyframes flicker {
            0%, 18%, 22%, 25%, 53%, 57%, 100% {
                text-shadow:
                0 0 4px #fff,
                0 0 11px #fff,
                0 0 19px #fff,
                0 0 40px var(--accent-color),
                0 0 80px var(--accent-color),
                0 0 90px var(--accent-color),
                0 0 100px var(--accent-color),
                0 0 150px var(--accent-color);
            }
            20%, 24%, 55% {      
                text-shadow: none;
            }
        }

        /* --- Touch Controls (for mobile) --- */
        .touch-controls {
            display: none; /* Hidden by default */
            margin-top: 1rem;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 0.5rem;
            width: 240px;
        }
        .touch-btn {
            background-color: var(--grid-bg);
            color: var(--text-color);
            border: 2px solid var(--grid-line);
            font-size: 1.5rem;
            padding: 0.75rem;
            user-select: none;
        }
        .touch-btn:active {
             background-color: var(--accent-color);
             color: var(--bg-color);
        }
        .touch-btn.rotate { grid-column: 2 / 3; grid-row: 1 / 2; }
        .touch-btn.left { grid-column: 1 / 2; grid-row: 2 / 3; }
        .touch-btn.down { grid-column: 2 / 3; grid-row: 2 / 3; }
        .touch-btn.right { grid-column: 3 / 4; grid-row: 2 / 3; }


        /* --- Responsive Design --- */
        @media (max-width: 768px) {
            body {
                align-items: flex-start;
                padding-top: 1rem;
            }
            .game-container {
                flex-direction: column;
                align-items: center;
                gap: 1rem;
            }
            .sidebar {
                flex-direction: row;
                width: 100%;
                max-width: 320px; /* Match canvas width */
                justify-content: space-around;
                gap: 1rem;
            }
            .stat-box {
                padding: 0.5rem;
                flex-grow: 1;
            }
            .stat-box h2 { font-size: 0.75rem; }
            .stat-box p { font-size: 1rem; }
            .next-piece-container { width: 80px; }
            #next-piece-canvas { width: 80px; height: 80px; }
            .touch-controls { display: grid; } /* Show on small screens */
        }
    </style>
</head>
<body>

    <div class="game-container">
        <canvas id="game-board"></canvas>

        <div class="sidebar">
            <div class="stat-box">
                <h2>Score</h2>
                <p id="score">0</p>
            </div>
            <div class="stat-box next-piece-container">
                <h2>Next</h2>
                <canvas id="next-piece-canvas"></canvas>
            </div>
            <button id="start-button" class="button">Start</button>
            <div class="touch-controls">
                <button class="touch-btn rotate" id="touch-rotate">⟳</button>
                <button class="touch-btn left" id="touch-left">←</button>
                <button class="touch-btn down" id="touch-down">↓</button>
                <button class="touch-btn right" id="touch-right">→</button>
            </div>
        </div>
    </div>

    <div id="instructions-modal" class="modal" style="display: flex;">
        <div class="modal-content">
            <h1>Tetris</h1>
            <p>Left/Right Arrows: Move</p>
            <p>Up Arrow / Space: Rotate</p>
            <p>Down Arrow: Soft Drop</p>
            <p class="start-prompt">Press Space to Start</p>
        </div>
    </div>

    <div id="game-over-modal" class="modal">
        <div class="modal-content">
            <h1>Game Over</h1>
            <p style="text-align: center;">Score: <span id="final-score">0</span></p>
            <button id="restart-button" class="button">Again</button>
            <p class="start-prompt">Or Press Space</p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Canvas and Context Setup ---
            const canvas = document.getElementById('game-board');
            const context = canvas.getContext('2d');
            const nextCanvas = document.getElementById('next-piece-canvas');
            const nextContext = nextCanvas.getContext('2d');

            // --- DOM Elements ---
            const scoreElement = document.getElementById('score');
            const restartButton = document.getElementById('restart-button');
            const gameOverModal = document.getElementById('game-over-modal');
            const finalScoreElement = document.getElementById('final-score');
            const instructionsModal = document.getElementById('instructions-modal');
            
            // --- Game Constants ---
            const COLS = 10;
            const ROWS = 20;
            const BLOCK_SIZE = 32;
            const COLORS = [
                null,
                '#FF00FF', // I (Magenta)
                '#00FFFF', // J (Cyan)
                '#FFFF00', // L (Yellow)
                '#00FF00', // O (Green)
                '#FF0000', // S (Red)
                '#FFA500', // T (Orange)
                '#0000FF', // Z (Blue)
            ];
            const SHAPES = [
                [], // Empty
                [[1, 1, 1, 1]], // I
                [[2, 0, 0], [2, 2, 2]], // J
                [[0, 0, 3], [3, 3, 3]], // L
                [[4, 4], [4, 4]], // O
                [[0, 5, 5], [5, 5, 0]], // S
                [[0, 6, 0], [6, 6, 6]], // T
                [[7, 7, 0], [0, 7, 7]], // Z
            ];

            // --- Game State ---
            let grid;
            let currentPiece;
            let nextPiece;
            let score;
            let isGameOver = true; // Start as true to prevent input before game starts
            let animationFrameId;
            let lastTime = 0;
            let dropCounter = 0;
            let dropInterval = 1000; // ms

            // --- Sound Engine ---
            let audioContext;
            const soundEffects = {
                rotate: { freq: 440, type: 'sine', dur: 0.05 },
                land: { freq: 110, type: 'square', dur: 0.1 },
                clear: { freq: 880, type: 'triangle', dur: 0.2 },
                gameOver: { freq: 220, type: 'sawtooth', dur: 0.5 }
            };

            function initAudio() {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
            }

            function playSound(name) {
                if (!audioContext || !soundEffects[name]) return;
                const sfx = soundEffects[name];
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.type = sfx.type;
                oscillator.frequency.setValueAtTime(sfx.freq, audioContext.currentTime);
                
                // For game over, create a falling pitch effect
                if (name === 'gameOver') {
                    oscillator.frequency.exponentialRampToValueAtTime(sfx.freq / 2, audioContext.currentTime + sfx.dur);
                }

                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + sfx.dur);

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + sfx.dur);
            }

            // --- Setup ---
            function setupCanvases() {
                canvas.width = COLS * BLOCK_SIZE;
                canvas.height = ROWS * BLOCK_SIZE;
                context.scale(BLOCK_SIZE, BLOCK_SIZE);
                nextCanvas.width = 4 * BLOCK_SIZE;
                nextCanvas.height = 4 * BLOCK_SIZE;
                nextContext.scale(BLOCK_SIZE, BLOCK_SIZE);
            }

            // --- Game Logic ---
            function init() {
                initAudio(); // Initialize audio on first interaction
                grid = createEmptyGrid();
                score = 0;
                isGameOver = false;
                dropInterval = 1000;
                updateScore();
                spawnNewPiece();
                spawnNewPiece(); // To populate current and next
                instructionsModal.style.display = 'none';
                gameOverModal.style.display = 'none';
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                gameLoop();
            }

            function gameLoop(time = 0) {
                if (isGameOver) return;

                const deltaTime = time - lastTime;
                lastTime = time;
                dropCounter += deltaTime;

                if (dropCounter > dropInterval) {
                    pieceDrop();
                }

                draw();
                animationFrameId = requestAnimationFrame(gameLoop);
            }

            function createEmptyGrid() {
                return Array.from({ length: ROWS }, () => Array(COLS).fill(0));
            }

            function spawnNewPiece() {
                const pieceType = Math.floor(Math.random() * (SHAPES.length - 1)) + 1;
                currentPiece = nextPiece || createPiece(pieceType);
                nextPiece = createPiece(Math.floor(Math.random() * (SHAPES.length - 1)) + 1);
                
                if (checkCollision(grid, currentPiece)) {
                    isGameOver = true;
                    showGameOver();
                }
            }
            
            function createPiece(type) {
                const matrix = SHAPES[type];
                return {
                    x: Math.floor(COLS / 2) - Math.floor(matrix[0].length / 2),
                    y: 0,
                    matrix: matrix,
                };
            }

            // --- Player Actions ---
            function pieceMove(direction) {
                currentPiece.x += direction;
                if (checkCollision(grid, currentPiece)) {
                    currentPiece.x -= direction;
                }
            }

            function pieceDrop() {
                currentPiece.y++;
                if (checkCollision(grid, currentPiece)) {
                    currentPiece.y--;
                    mergePieceToGrid();
                    playSound('land');
                    clearLines();
                    spawnNewPiece();
                    dropInterval = Math.max(150, 1000 - score); // Speed up
                }
                dropCounter = 0;
            }

            function pieceRotate() {
                playSound('rotate');
                const originalMatrix = currentPiece.matrix;
                currentPiece.matrix = rotateMatrix(currentPiece.matrix);
                
                let offset = 1;
                while (checkCollision(grid, currentPiece)) {
                    currentPiece.x += offset;
                    offset = -(offset + (offset > 0 ? 1 : -1));
                    if (offset > currentPiece.matrix[0].length) {
                        currentPiece.matrix = originalMatrix; // Revert if can't fit
                        return;
                    }
                }
            }

            function rotateMatrix(matrix) {
                const rows = matrix.length;
                const cols = matrix[0].length;
                const newMatrix = Array.from({ length: cols }, () => Array(rows).fill(0));
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        newMatrix[c][rows - 1 - r] = matrix[r][c];
                    }
                }
                return newMatrix;
            }

            // --- Collision & Grid ---
            function checkCollision(grid, piece) {
                const { matrix, x, y } = piece;
                for (let r = 0; r < matrix.length; r++) {
                    for (let c = 0; c < matrix[r].length; c++) {
                        if (matrix[r][c] !== 0) {
                            const newX = x + c;
                            const newY = y + r;
                            if (newX < 0 || newX >= COLS || newY >= ROWS || (grid[newY] && grid[newY][newX] !== 0)) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            function mergePieceToGrid() {
                const { matrix, x, y } = currentPiece;
                matrix.forEach((row, r) => {
                    row.forEach((value, c) => {
                        if (value !== 0) {
                            grid[y + r][x + c] = value;
                        }
                    });
                });
            }

            function clearLines() {
                let linesCleared = 0;
                outer: for (let r = ROWS - 1; r >= 0; r--) {
                    for (let c = 0; c < COLS; c++) {
                        if (grid[r][c] === 0) continue outer;
                    }
                    const row = grid.splice(r, 1)[0].fill(0);
                    grid.unshift(row);
                    r++;
                    linesCleared++;
                }
                if (linesCleared > 0) {
                    playSound('clear');
                    // Score based on Tetris guideline
                    const linePoints = [0, 40, 100, 300, 1200];
                    score += linePoints[linesCleared];
                    updateScore();
                }
            }

            // --- Drawing ---
            function draw() {
                context.fillStyle = '#1a1a1a';
                context.fillRect(0, 0, canvas.width, canvas.height);
                drawMatrix(context, grid, { x: 0, y: 0 });
                if (currentPiece) {
                    drawMatrix(context, currentPiece.matrix, { x: currentPiece.x, y: currentPiece.y });
                }
                drawNextPiece();
            }
            
            function drawMatrix(ctx, matrix, offset) {
                matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            ctx.fillStyle = COLORS[value];
                            ctx.fillRect(x + offset.x, y + offset.y, 1, 1);
                        }
                    });
                });
            }

            function drawNextPiece() {
                nextContext.fillStyle = '#1a1a1a';
                nextContext.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
                if (nextPiece) {
                    const { matrix } = nextPiece;
                    const offsetX = (4 - matrix[0].length) / 2;
                    const offsetY = (4 - matrix.length) / 2;
                    drawMatrix(nextContext, matrix, { x: offsetX, y: offsetY });
                }
            }

            // --- UI ---
            function updateScore() {
                scoreElement.innerText = score;
            }

            function showGameOver() {
                playSound('gameOver');
                cancelAnimationFrame(animationFrameId);
                finalScoreElement.innerText = score;
                gameOverModal.style.display = 'flex';
            }

            // --- Event Listeners ---
            document.addEventListener('keydown', event => {
                // Start/Restart game with Spacebar
                if (event.key === ' ' && isGameOver) {
                    event.preventDefault();
                    init();
                    return;
                }

                if (isGameOver) return;

                const actions = {
                    'ArrowLeft': () => pieceMove(-1),
                    'ArrowRight': () => pieceMove(1),
                    'ArrowDown': () => pieceDrop(),
                    'ArrowUp': () => pieceRotate(),
                    ' ': () => pieceRotate(),
                };
                if (actions[event.key]) {
                    event.preventDefault();
                    actions[event.key]();
                }
            });

            // Touch controls
            document.getElementById('touch-left').addEventListener('click', () => !isGameOver && pieceMove(-1));
            document.getElementById('touch-right').addEventListener('click', () => !isGameOver && pieceMove(1));
            document.getElementById('touch-down').addEventListener('click', () => !isGameOver && pieceDrop());
            document.getElementById('touch-rotate').addEventListener('click', () => {
                if (!isGameOver) {
                    initAudio(); // Ensure audio is ready for touch
                    pieceRotate();
                }
            });

            restartButton.addEventListener('click', init);

            // --- Initial Call ---
            setupCanvases();
            context.fillStyle = '#1a1a1a';
            context.fillRect(0, 0, canvas.width, canvas.height);
        });
    </script>
</body>
</html>
