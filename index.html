<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Bash</title>
    <link rel="icon" type="image/png" href="https://cdn-icons-png.flaticon.com/512/566/566312.png">
    <link href="https://fonts.googleapis.com/css2?family=Raleway:wght@700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #4c6ef5;
            --text-color: #ffffff;
            --score-bg: #e2e8f0;
            --button-bg: #2b458b;
            --button-hover-bg: #364fc7;
            --game-over-bg: rgba(0, 0, 0, 0.7);
            --modal-bg: #2f4996;
            --block-color-1: #38a169;
            --block-color-2: #3182ce;
            --block-color-3: #dd6b20;
            --block-color-4: #ed8936;
            --block-color-5: #6b46c1;
            --block-color-6: #e53e3e;
            --board-border: #2b458b; /* Dark border for grid */
            --cell-bg: #3b5093; /* Darker cell background for contrast */
            --cell-active-bg: #4c68b7;
        }

        body {
            font-family: 'Raleway', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            backdrop-filter: blur(8px); /* Subtle blur to make content pop */
        }

        .container {
            background-color: transparent;
            border-radius: 1rem;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 90%;
            border: none;
            box-shadow: none;
        }
        
        .header-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 2rem;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--text-color);
            margin: 0 0 1rem;
            letter-spacing: -0.05em;
            text-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }

        .score-display {
            background-color: var(--score-bg);
            padding: 0.75rem 1.5rem;
            border-radius: 9999px;
            font-size: 1.25rem;
            font-weight: 700;
            min-width: 150px;
            text-align: center;
            position: relative;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2), 0 2px 5px rgba(0,0,0,0.2);
            color: #334e68;
        }

        .game-area {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .game-board {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 4px;
            background-color: var(--board-border);
            border-radius: 0.5rem;
            padding: 4px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2);
        }

        .cell {
            width: 40px;
            height: 40px;
            background-color: var(--cell-bg);
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
            box-shadow: inset 0 2px 2px rgba(255,255,255,0.1), inset 0 -2px 2px rgba(0,0,0,0.2);
        }

        .cell:hover:not([data-filled="true"]):not([data-highlight="true"]) {
            background-color: var(--cell-active-bg);
        }

        .cell[data-filled="true"] {
            background-color: var(--block-color);
            box-shadow: inset 0 4px 4px rgba(255,255,255,0.2), inset 0 -4px 4px rgba(0,0,0,0.3);
            border-radius: 4px;
        }

        .cell[data-highlight="true"] {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .block-selector-container {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin-top: 2rem;
            min-height: 120px;
        }

        .block-container {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            border-radius: 0.5rem;
            padding: 0.5rem;
            cursor: pointer;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            opacity: 1;
        }

        .block-container.selected {
            opacity: 1;
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
        }

        .block-grid {
            display: grid;
            gap: 6px;
        }

        .block-cell {
            width: 30px;
            height: 30px;
            border-radius: 3px;
        }

        .buttons-container {
            margin-top: 2rem;
            display: flex;
            gap: 1rem;
        }

        .btn {
            background-color: var(--button-bg);
            color: white;
            padding: 0.75rem 2rem;
            border: none;
            border-radius: 9999px;
            font-family: 'Raleway', sans-serif;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out, box-shadow 0.2s ease-in-out;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .btn:hover {
            background-color: var(--button-hover-bg);
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3);
        }

        .game-over-message, .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: var(--game-over-bg);
            backdrop-filter: blur(5px);
            z-index: 20;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease-in-out, visibility 0.5s ease-in-out;
        }

        .modal.visible, .game-over-message.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: var(--modal-bg);
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 500px;
            color: var(--text-color);
            position: relative;
        }

        .modal-content h2 {
            font-size: 2rem;
            margin-bottom: 1rem;
            font-weight: 700;
        }

        .modal-content p {
            font-size: 1rem;
            line-height: 1.5;
            text-align: left;
        }

        .modal-content ul {
            text-align: left;
            padding-left: 1.5rem;
        }

        .modal-close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 1.5rem;
            color: var(--text-color);
            cursor: pointer;
        }

        @media (max-width: 600px) {
            .cell {
                width: 30px;
                height: 30px;
            }

            .block-cell {
                width: 20px;
                height: 20px;
            }

            .block-selector-container {
                gap: 1rem;
            }

            h1 {
                font-size: 2rem;
            }

            .score-display {
                font-size: 1rem;
            }

            .game-over-message {
                font-size: 1.2rem;
            }
        }
    </style>
</head>
<body>

<div class="container">
    <div class="header-section">
        <h1>Block Bash</h1>
        <div class="score-display">Score: 0</div>
    </div>
    <div class="game-area">
        <div class="game-board" id="game-board"></div>
        <div class="game-over-message" id="game-over-message">
            Game Over!
            <p>Your Score: <span id="final-score">0</span></p>
        </div>
    </div>
    <div class="block-selector-container" id="block-selector-container"></div>
    <div class="buttons-container">
        <button class="btn" id="new-game-btn">New Game</button>
        <button class="btn" id="instructions-btn">How to Play</button>
    </div>
</div>

<!-- Instructions Modal -->
<div id="instructions-modal" class="modal">
    <div class="modal-content">
        <button class="modal-close-btn" id="close-modal-btn">&times;</button>
        <h2>How to Play</h2>
        <p>Your goal is to clear as many blocks as possible from the 9x9 grid. You'll receive three random blocks at a time.</p>
        <ul>
            <li>Tap on a block from the bottom selector to pick it up.</li>
            <li>Tap on an empty spot on the grid to place the block.</li>
            <li>Clear blocks by filling a complete row, column, or a 3x3 square.</li>
            <li>The more lines you clear at once, the more points you get!</li>
        </ul>
        <p>The game ends when you can no longer place any of the three available blocks on the board.</p>
    </div>
</div>

<script>
    // --- Game Constants and Setup ---
    const BOARD_SIZE = 9;
    const gameBoardEl = document.getElementById('game-board');
    const scoreEl = document.querySelector('.score-display');
    const blockSelectorEl = document.getElementById('block-selector-container');
    const newGameBtn = document.getElementById('new-game-btn');
    const instructionsBtn = document.getElementById('instructions-btn');
    const gameOverMessageEl = document.getElementById('game-over-message');
    const finalScoreEl = document.getElementById('final-score');
    const instructionsModal = document.getElementById('instructions-modal');
    const closeModalBtn = document.getElementById('close-modal-btn');

    // Block color palette
    const colors = [
        'var(--block-color-1)',
        'var(--block-color-2)',
        'var(--block-color-3)',
        'var(--block-color-4)',
        'var(--block-color-5)',
        'var(--block-color-6)'
    ];

    // Define the block shapes. Each shape is a 2D array of 1s and 0s.
    // The dimensions of the inner arrays determine the size of the block grid.
    const blockShapes = [
        { shape: [[1]], size: 1 },
        { shape: [[1, 1]], size: 2 },
        { shape: [[1], [1]], size: 2 },
        { shape: [[1, 1], [1, 1]], size: 2 },
        { shape: [[1, 1, 1]], size: 3 },
        { shape: [[1], [1], [1]], size: 3 },
        { shape: [[0, 1], [1, 1]], size: 2 },
        { shape: [[1, 0], [1, 1]], size: 2 },
        { shape: [[1, 1], [0, 1]], size: 2 },
        { shape: [[1, 1], [1, 0]], size: 2 },
        { shape: [[1, 1, 1], [0, 1, 0]], size: 3 }, // T-shape
        { shape: [[1, 1, 0], [0, 1, 1]], size: 3 }, // Z-shape
    ];

    let gameState = {};
    let highlightedCells = [];

    // --- Core Game Functions ---
    /**
     * Initializes a new game state.
     */
    function initGame() {
        gameState = {
            board: Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(null)),
            score: 0,
            selectedBlock: null,
            availableBlocks: []
        };
        // Generate the initial set of 3 blocks
        generateRandomBlocks();
        // Hide the game over message
        gameOverMessageEl.classList.remove('visible');
        // Clear the game board UI
        gameBoardEl.innerHTML = '';
        // Draw the initial state
        draw();
    }

    /**
     * Generates a new set of 3 random blocks for the selector area.
     */
    function generateRandomBlocks() {
        gameState.availableBlocks = [];
        for (let i = 0; i < 3; i++) {
            const randomIndex = Math.floor(Math.random() * blockShapes.length);
            const randomColorIndex = Math.floor(Math.random() * colors.length);
            gameState.availableBlocks.push({
                shape: blockShapes[randomIndex].shape,
                color: colors[randomColorIndex],
                size: blockShapes[randomIndex].size,
                id: Date.now() + i // Unique ID for each block
            });
        }
    }

    /**
     * Renders the entire game state to the DOM.
     */
    function draw() {
        drawBoard();
        drawBlocks();
        updateScore();
    }

    /**
     * Renders the game board.
     */
    function drawBoard() {
        gameBoardEl.innerHTML = '';
        for (let r = 0; r < BOARD_SIZE; r++) {
            for (let c = 0; c < BOARD_SIZE; c++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                cell.dataset.row = r;
                cell.dataset.col = c;
                if (gameState.board[r][c] !== null) {
                    cell.dataset.filled = 'true';
                    cell.style.backgroundColor = gameState.board[r][c];
                }
                gameBoardEl.appendChild(cell);
            }
        }
    }

    /**
     * Renders the available blocks in the selector area.
     */
    function drawBlocks() {
        blockSelectorEl.innerHTML = '';
        gameState.availableBlocks.forEach(block => {
            const blockContainer = document.createElement('div');
            blockContainer.classList.add('block-container');
            if (gameState.selectedBlock && gameState.selectedBlock.id === block.id) {
                blockContainer.classList.add('selected');
            }
            blockContainer.dataset.blockId = block.id;
            blockContainer.style.gridTemplateColumns = `repeat(${block.shape[0].length}, 1fr)`;

            const blockGrid = document.createElement('div');
            blockGrid.classList.add('block-grid');
            blockGrid.style.gridTemplateColumns = `repeat(${block.shape[0].length}, 1fr)`;
            
            for (let r = 0; r < block.shape.length; r++) {
                for (let c = 0; c < block.shape[0].length; c++) {
                    const blockCell = document.createElement('div');
                    blockCell.classList.add('block-cell');
                    if (block.shape[r][c] === 1) {
                        blockCell.style.backgroundColor = block.color;
                        blockCell.style.boxShadow = `inset 0 2px 2px rgba(255,255,255,0.2), inset 0 -2px 2px rgba(0,0,0,0.3)`;
                    }
                    blockGrid.appendChild(blockCell);
                }
            }
            blockContainer.appendChild(blockGrid);
            blockSelectorEl.appendChild(blockContainer);
        });
    }

    /**
     * Updates the score display.
     */
    function updateScore() {
        scoreEl.textContent = `${gameState.score}`;
    }

    /**
     * Checks if a block can be placed at a given position.
     * @param {Object} block - The block to be placed.
     * @param {number} startRow - The starting row.
     * @param {number} startCol - The starting column.
     * @returns {boolean} True if the block can be placed, false otherwise.
     */
    function canPlaceBlock(block, startRow, startCol) {
        for (let r = 0; r < block.shape.length; r++) {
            for (let c = 0; c < block.shape[0].length; c++) {
                if (block.shape[r][c] === 1) {
                    const boardRow = startRow + r;
                    const boardCol = startCol + c;
                    if (
                        boardRow >= BOARD_SIZE ||
                        boardCol >= BOARD_SIZE ||
                        gameState.board[boardRow][boardCol] !== null
                    ) {
                        return false;
                    }
                }
            }
        }
        return true;
    }

    /**
     * Places a block on the game board.
     * @param {Object} block - The block to be placed.
     * @param {number} startRow - The starting row.
     * @param {number} startCol - The starting column.
     */
    function placeBlock(block, startRow, startCol) {
        for (let r = 0; r < block.shape.length; r++) {
            for (let c = 0; c < block.shape[0].length; c++) {
                if (block.shape[r][c] === 1) {
                    gameState.board[startRow + r][startCol + c] = block.color;
                }
            }
        }
        // Increase score for each cell placed
        const scoreToAdd = block.shape.flat().filter(cell => cell === 1).length;
        gameState.score += scoreToAdd;

        // Remove the block from the available blocks list
        gameState.availableBlocks = gameState.availableBlocks.filter(b => b.id !== block.id);
        gameState.selectedBlock = null;
    }

    /**
     * Checks for and clears completed rows, columns, and 3x3 squares.
     * Awards points for cleared blocks.
     */
    function checkAndClear() {
        let linesCleared = 0;
        let blocksCleared = 0;
        let cellsToClear = new Set();

        // Check for completed rows and columns
        for (let i = 0; i < BOARD_SIZE; i++) {
            // Check row i
            let rowFull = true;
            let colFull = true;
            for (let j = 0; j < BOARD_SIZE; j++) {
                if (gameState.board[i][j] === null) rowFull = false;
                if (gameState.board[j][i] === null) colFull = false;
            }
            if (rowFull) {
                for (let j = 0; j < BOARD_SIZE; j++) cellsToClear.add(`${i}-${j}`);
                linesCleared++;
            }
            if (colFull) {
                for (let j = 0; j < BOARD_SIZE; j++) cellsToClear.add(`${j}-${i}`);
                linesCleared++;
            }
        }

        // Check for completed 3x3 squares
        for (let r = 0; r <= BOARD_SIZE - 3; r += 3) {
            for (let c = 0; c <= BOARD_SIZE - 3; c += 3) {
                let squareFull = true;
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        if (gameState.board[r + i][c + j] === null) {
                            squareFull = false;
                            break;
                        }
                    }
                    if (!squareFull) break;
                }
                if (squareFull) {
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 3; j++) {
                            cellsToClear.add(`${r + i}-${c + j}`);
                        }
                    }
                    blocksCleared++;
                }
            }
        }

        // Clear the cells
        cellsToClear.forEach(cellKey => {
            const [r, c] = cellKey.split('-').map(Number);
            gameState.board[r][c] = null;
        });

        // Award points for clearing
        const clearedCount = cellsToClear.size;
        if (clearedCount > 0) {
            gameState.score += clearedCount * 10;
        }
    }

    /**
     * Checks if the game is over.
     * The game is over if none of the available blocks can be placed anywhere on the board.
     * @returns {boolean} True if the game is over, false otherwise.
     */
    function checkGameOver() {
        if (gameState.availableBlocks.length === 0) {
            generateRandomBlocks();
            return false;
        }

        for (const block of gameState.availableBlocks) {
            for (let r = 0; r <= BOARD_SIZE - block.shape.length; r++) {
                for (let c = 0; c <= BOARD_SIZE - block.shape[0].length; c++) {
                    if (canPlaceBlock(block, r, c)) {
                        return false;
                    }
                }
            }
        }
        return true;
    }

    /**
     * Highlights the possible placement area for the selected block.
     */
    function highlightCells(event) {
        if (!gameState.selectedBlock) return;
        
        clearHighlights();

        const cell = event.target.closest('.cell');
        if (!cell) return;

        const row = Number(cell.dataset.row);
        const col = Number(cell.dataset.col);

        if (canPlaceBlock(gameState.selectedBlock, row, col)) {
            for (let r = 0; r < gameState.selectedBlock.shape.length; r++) {
                for (let c = 0; c < gameState.selectedBlock.shape[0].length; c++) {
                    if (gameState.selectedBlock.shape[r][c] === 1) {
                        const targetCell = gameBoardEl.querySelector(`[data-row="${row + r}"][data-col="${col + c}"]`);
                        if (targetCell) {
                            targetCell.dataset.highlight = 'true';
                            highlightedCells.push(targetCell);
                        }
                    }
                }
            }
        }
    }

    /**
     * Clears all highlighted cells.
     */
    function clearHighlights() {
        highlightedCells.forEach(cell => {
            cell.dataset.highlight = 'false';
        });
        highlightedCells = [];
    }

    // --- Event Listeners and Game Flow ---
    document.addEventListener('DOMContentLoaded', initGame);

    newGameBtn.addEventListener('click', () => {
        initGame();
    });

    instructionsBtn.addEventListener('click', () => {
        instructionsModal.classList.add('visible');
    });

    closeModalBtn.addEventListener('click', () => {
        instructionsModal.classList.remove('visible');
    });

    blockSelectorEl.addEventListener('click', (event) => {
        const blockContainer = event.target.closest('.block-container');
        if (blockContainer) {
            const blockId = Number(blockContainer.dataset.blockId);
            const block = gameState.availableBlocks.find(b => b.id === blockId);
            if (gameState.selectedBlock && gameState.selectedBlock.id === blockId) {
                gameState.selectedBlock = null; // Deselect
                clearHighlights();
            } else {
                gameState.selectedBlock = block;
            }
            drawBlocks();
        }
    });

    gameBoardEl.addEventListener('click', (event) => {
        const cell = event.target.closest('.cell');
        if (cell && gameState.selectedBlock) {
            const row = Number(cell.dataset.row);
            const col = Number(cell.dataset.col);

            if (canPlaceBlock(gameState.selectedBlock, row, col)) {
                placeBlock(gameState.selectedBlock, row, col);
                checkAndClear();
                clearHighlights();
                if (checkGameOver()) {
                    finalScoreEl.textContent = gameState.score;
                    gameOverMessageEl.classList.add('visible');
                }
                draw();
            }
        }
    });

    gameBoardEl.addEventListener('mouseover', highlightCells);
    gameBoardEl.addEventListener('mouseout', clearHighlights);

</script>
</body>
</html>
